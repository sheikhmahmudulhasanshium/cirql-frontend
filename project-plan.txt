Changelog - v1.2.2 (2024-06-30)
minor Update
ui update for contact and admin panel

To-Do: Create a Throttled & Efficient "My Activity" Dashboard for Users
Goal: Give users a personal activity dashboard, but do it in a way that prevents server overload and minimizes database costs.
Phase 1: Safe & Low-Cost Data Recording (Backend Only)
(This phase is designed to be extremely lightweight and will not crash your server.)
Plan:
Create an "Activity Log" with Safeguards:
Use a Capped Collection: When creating the new table (schema) in MongoDB, we will define it as a "Capped Collection." This is a crucial step. A capped collection has a fixed size (e.g., 20MB). When it gets full, it automatically deletes the oldest entries to make room for new ones.
Result: Your database will never grow infinitely large with log data. This keeps storage costs predictable and low, and prevents performance from degrading over time.
Use a "Fire-and-Forget" Logging Service:
The new ActivityLogService on the backend will be designed to be non-blocking. When a user logs in, the logEvent call will be sent to the database, but the main login process will not wait for it to finish.
Result: Even if the database is slow for a moment, it will never slow down or crash the user's main action (like logging in or sending a message).
Be Selective about What to Log:
We will only log a few, high-value events to start. We will avoid logging extremely frequent actions (like every single click).
Initial Events to Log:
User Login
User Profile View (throttled - see next point)
Ticket Message Sent
Result: We collect meaningful data without spamming the database with millions of trivial events.
Throttle High-Frequency Events (Optional but Recommended):
For actions that could happen very quickly (like a user repeatedly viewing profiles), we can add a "throttler" on the backend. This means the backend will only record one VIEW_PROFILE event for a specific user every, for example, 30 seconds.
Result: This prevents a single hyperactive user from overwhelming the logging system, further protecting your server.
Phase 2: Efficient Data Reading (Future Feature)
(This phase ensures that showing the dashboard to the user is also fast and cheap.)
Plan:
Backend Summarizes, Frontend Displays:
The backend API endpoint will do all the heavy lifting. It will use highly optimized database commands (the "Aggregation Pipeline") to count and summarize the logs.
It will not send thousands of raw log entries to the frontend. It will send a tiny, pre-calculated summary like { "totalLogins": 15 }.
Result: The amount of data transferred is minimal, which is fast for the user and cheap for your server costs. The frontend's job remains simple: just display the numbers it's given.
Cache the Results:
For the user's activity dashboard, the data doesn't need to be real-time to the millisecond. We can cache the results on the backend for, say, 1 hour. If a user refreshes their activity page 10 times in 30 minutes, we only hit the database once. The other 9 times, we serve the result instantly from memory.
Result: This dramatically reduces the number of database queries, which is the biggest factor in both server stress and cost.
To-Do: Create "My Activity" Dashboard for Users
Goal: Give users a personal dashboard where they can see their own activity on the platform, like a "digital footprint." This will include stats like login frequency and total interactions, shown with cool charts and graphs.
Phase 1: Start Recording User Actions (Backend Only)
(This phase is completely invisible to users and has zero impact on the UI. It's the "data collection" step.)
Plan:
Create an "Activity Log" in the Database: Build a new, separate table (schema) in the database just for recording simple user actions.
Start Logging Key Events: In the backend code, add a single line of code to the "Activity Log" every time a user does something important, like:
Logging in.
Sending a message.
Viewing a profile.
Result: The application will begin silently and efficiently collecting activity data in the background.
Phase 2: Build the User-Facing Dashboard (Future Feature)
(This is the phase where we build the actual page for the user to see.)
Plan:
Build a "Data Summarizer" on the Backend: Create a new API endpoint (e.g., /users/me/activity) that can quickly count and summarize the raw data from the "Activity Log" for a specific user. It will return simple numbers, like { "loginsLast30Days": 10, "messagesSent": 55 }.
Design the "My Activity" Page: On the frontend, create a new page where users can see their stats.
Add Charts: Use the Recharts library (which is already in the project) to turn the summarized numbers from the API into nice-looking bar charts and graphs.
Result: A beautiful, engaging "My Activity" page where users can visualize their own engagement on the platform, similar to features on sites like YouTube or Facebook.

ignore for now
To-Do: Add "Talking Feedback" for Settings Toggles
Goal: When a user with a screen reader flips a switch in their settings (like "Dark Mode" or "Private Account"), we want the website to announce the change out loud, for example, "Dark mode enabled."
Plan:
Create an "Announcer" Component: Build a special, invisible component that can speak messages to screen readers.
Add it to the Settings Page: Place this Announcer component on the settings page so it's ready to work.
Connect the Toggles: Update the logic for the settings toggles. When a switch is flipped, tell the Announcer what to say.
User Control: The Announcer will only speak if the "Screen Reader Support" switch is turned ON in the user's settings. If it's off, it will stay silent.
Result: This will make the settings page much more accessible and user-friendly for visually impaired users without changing the website's appearance or SEO.